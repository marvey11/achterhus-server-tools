#! /usr/bin/env python3

import json
import sys
from pathlib import Path

# Add the project root to sys.path
project_root = Path(__file__).resolve().parent.parent
if str(project_root) not in sys.path:
    sys.path.insert(0, str(project_root))


from lib.configuration import Configuration


def main() -> None:
    json_env_file = project_root / ".env.json"

    user_home = Path.home()

    try:
        config = Configuration.from_json(json_env_file)
    except (json.JSONDecodeError, ValueError):
        print(
            f"❌ Error: {json_env_file.name} is not valid JSON configuration.",
            file=sys.stderr,
        )
        sys.exit(1)

    try:
        config.validate(["photo-inbox", "status-dir", "storage-dir"])
    except ValueError as e:
        print(f"❌ Configuration error: {e}", file=sys.stderr)
        sys.exit(1)

    # Define configuration keys and their default values.
    status_dir = config.get_path("status-dir", user_home)
    photo_inbox = config.get_path("photo-inbox", user_home)
    storage_dir = config.get_path("storage-dir")

    # Construct the final environment variables. Using resolve() ensures all
    # paths are absolute and unambiguous.
    env_config = {
        "SERVICE_STATUS_DIR": status_dir,
        "PHOTO_INBOX": photo_inbox,
        "PHOTO_STORAGE": (Path(storage_dir) / "photo").resolve(),
    }

    env_path = project_root / ".env"
    with open(env_path, "w", encoding="utf-8") as env_file:
        env_file.write("# GENERATED BY generate_env.py - DO NOT EDIT\n")
        for key, value in env_config.items():
            # Wrap in quotes to prevent bash word-splitting on spaces
            env_file.write(f'{key}="{value}"\n')

    print(f"✅ Created {env_path}")


if __name__ == "__main__":
    main()
