#! /usr/bin/env python3

import json
import sys
from pathlib import Path

from lib.configuration import Configuration


def main() -> None:
    project_root = Path(__file__).resolve().parent.parent
    json_env_file = project_root / ".env.json"

    user_home = Path.home()

    try:
        config = Configuration.from_json(json_env_file)
    except (json.JSONDecodeError, ValueError):
        print(
            f"❌ Error: {json_env_file.name} is not valid JSON configuration.",
            file=sys.stderr,
        )
        sys.exit(1)

    try:
        config.validate(["status-dir", "photo-inbox", "storage-dir"])
    except ValueError as e:
        print(f"❌ Configuration error: {e}", file=sys.stderr)
        sys.exit(1)

    # Define configuration keys and their default values.
    status_dir = config.get("status-dir", ".cache/achterhus/status")
    photo_inbox = config.get("photo-inbox", "photo-inbox")
    storage_dir = config.get("storage-dir", str(user_home))

    # Construct the final environment variables. Using resolve() ensures all
    # paths are absolute and unambiguous.
    env_config = {
        "SERVICE_STATUS_DIR": (user_home / status_dir).resolve(),
        "PHOTO_INBOX": (user_home / photo_inbox).resolve(),
        "PHOTO_STORAGE": (Path(storage_dir) / "photo").resolve(),
    }

    env_path = project_root / ".env"
    with open(env_path, "w", encoding="utf-8") as env_file:
        env_file.write("# GENERATED BY generate_env.py - DO NOT EDIT\n")
        for key, value in env_config.items():
            # Wrap in quotes to prevent bash word-splitting on spaces
            env_file.write(f'{key}="{value}"\n')

    print(f"✅ Created {env_path}")


if __name__ == "__main__":
    main()
